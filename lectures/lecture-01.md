Зміст:
- [Мови програмування](#мови-програмування)
	- [Прагматичний аспект](#прагматичний-аспект)
	- [Семантичний аспект](#семантичний-аспект)
	- [Синтаксичний аспект](#синтаксичний-аспект)
- [Мовні процесори](#мовні-процесори)
	- [Структура транслятора](#структура-транслятора)
	- [Призначення основних компонентів транслятора](#призначення-основних-компонентів-транслятора)
- [Контрольні запитання](#контрольні-запитання)

## Мови програмування

При вивченні мов програмування, як правило, виділяють три аспекти:
- Прагматичний;
- Семантичний;
- Синтаксичний.

### Прагматичний аспект

_Прагматичний аспект_ (прагматика мови програмування) визначає клас задач, на
розв'язування яких орієнтується мова програмування. Як правило, прагматичний аспект
менш формалізований у порівнянні з семантичним та синтаксичним аспектами.

За класом задач на розв'язування яких орієнтуються мови програмування 
їх можна поділити передусім на 
- процедурні;
- непроцедурні.

_Процедурні_ мови програмування орієнтовані перш за все на опис
(визначення) алгоритмів, тобто по суті використовуються для побудови процедур
обробки даних. До таких мов ми відносимо всім відомі мови програмування, такі
як `Pascal`, `Fortran`, `C` та ін.

_Непроцедурні_ мови програмування на відміну від процедурних неявно
визначають процедури обробки даних. Частіше всього такі мови
використовуються для побудови завдань на обробку даних. При цьому, за
допомогою інструкцій непроцедурної мови програмування визначається що
необхідно зробити з даними і явно не визначається як (з використанням яких
алгоритмів) необхідно розв'язати задачу. До непроцедурних мов програмування
ми відносимо командні мови операційних систем, мови управління в пакетах
прикладних програм та ін.

Як процедурні, так і непроцедурні мови програмування можуть
орієнтуватися як на декілька класів задач, так і конкретну предметну область. У
першому випадку ми будемо говорити про _універсальні_ мови програмування
(`Pascal`, `Fortran`, `C`), в другому &mdash; про _спеціалізовані_
мови програмування (`Snobol`, `Lisp`).

### Семантичний аспект

_Семантичний аспект_ (семантика мови програмування) визначається
шляхом конкретизації базових функцій обробки даних, набору конструкцій
управління та методами побудови більш "складних" програм на основі "простих".

Наприклад, визначивши як базовий тип даних "рядок" ми повинні
запропонувати "традиційний" набір функцій обробки таких даних: порівняння
рядків, виділення частини рядка, конкатенацію рядків та ін.

Семантика мови програмування має бути визначена формально, бо інакше у
подальшому неможливо буде побудувати відповідний мовний процесор. Станом на
сьогодні існують два основних напрямки визначення семантики мов
програмування: 
- методи денотаційної семантики;
- методи операційної семантики.

Методи _денотаційної семантики_ базуються на відповідних алгебрах, методи
_операційної семантики_ базуються на синтаксичних структурах програм.

### Синтаксичний аспект

_Синтаксичний аспект_ (синтаксис мови програмування) визначає набір
синтаксичних конструкцій мови програмування, які використовуються для нотації
(запису) семантичних одиниць в програмі. Про синтаксис мови програмування
можна сказати як про форму, яка є суть похідною від семантики. Для визначення
(опису) синтаксису мови програмування використовуються як механізми, що
орієнтовані на синтез, так і механізми, орієнтовані на аналіз. 

Задачі аналізу та синтезу синтаксичних структур програм &mdash; це дуальні задачі. 
Їх конкретизацію ми будемо розглядати в наступних розділах.

Виходячи з вищенасказаного, щоб побудувати мову програмування потрібно:
- визначити клас (класи) задач, на розв'язок яких орієнтована мова 
	програмування;
- виділити базові типи даних та функції їх обробки, вказати конструкції
	управління в програмах. Побудувати механізми конструювання більш складних
	програм та структур даних на основі більш простих одиниць;
- визначити синтаксис мови програмування.

## Мовні процесори

_Мовні процесори_ реалізують мови програмування. Точніше, мовний
процесор призначений для обробки програм відповідної мови програмування. З
точки зору прагматики, мовні процесори діляться на
- транслятори;
- інтерпретатори.

_Мовний процесор типу транслятор (транслятор)_ &mdash; це програмний
комплекс, котрий на вході отримує текст програми на вхідній мові, а на виході
видає версію програми на вихідній мові, що називається об'єктною мовою. В
більшості випадків як об'єктна мова виступає мова команд деякої обчислювальної
машини. Серед трансляторів можна виділити дві програмні системи:
- компілятори &mdash; транслятори з мов програмування високого рівня;
- асемблери &mdash; транслятори машинно-орієнтованих мов програмування.

_Мовний процесор типу інтерпретатор (інтерпретатор)_ &mdash; це програмний
комплекс, котрий на вході отримує текст програми на вхідній мові та вхідні дані,
які в подальшому обробляються програмою, а на виході видає результати
обчислень (вихідні дані).

Оскільки транслятори та інтерпретатори реалізують мови програмування,
вони мають спільні риси: їх структура досить схожа, в основу їх реалізації
покладено спільні теоретичні результати та практичні методи реалізації.

### Структура транслятора

1. Вхідний текст програми
2. Лексичний аналіз
3. Синтаксичний аналіз
4. Семантичний аналіз
5. Оптимізація проміжного коду
6. Генерація коду
7. Вихідний (об'єктний) код

### Призначення основних компонентів транслятора

1. _Лексичний аналізатор._
	
	**Вхід:** вхідний текст (послідовність літер) програми.

	**Вихід:** послідовність лексем програми.

	_Лексема_ &mdash; це ланцюжок літер, що має певний зміст. Всі лексеми мови
	програмування (їх кількість, як правило, нескінчена) можна розбити на скінчену
	множину класів. Для більшості мов програмування актуальні наступні класи
	лексем:
	- зарезервовані слова;
	- ідентифікатори;
	- числові константи (цілі та дійсні числа);
	- літерні константи;
	- рядкові константи;
	- коди операцій;
	- коментарі. Безпосередньо не несуть інформації щодо структури
		програми. В подальшому не використовуються, тобто не передаються
		синтаксичному аналізатору.
	- дужки та інші елементи програми.
2. _Синтаксичний аналізатор._

	**Вхід:** послідовність лексем програми.
	
	**Вихід:**
	
	- "Так" + синтаксична структура (синтаксичний терм) програми,
	- "Ні" + синтаксичні помилки в програмі.
3. _Семантичний аналізатор._

	**Вхід:** Синтаксичний терм програми.

	**Вихід:**
	- "Так" + семантична структура (семантичний терм) програми,
	- "Ні" + семантичні помилки в програмі.
4. _Оптимізація проміжного коду._

	**Вхід:** семантичний терм програми.

	**Вихід:** оптимізований семантичний терм програми.

	_Оптимізація_ &mdash; це еквівалентне перетворення програми на основі певних
	критеріїв. Серед критеріїв оптимізації можна виділити:
	- оптимізацію по пам'яті;
	- оптимізацію по швидкості виконання. 
	
	В залежності від підходів по оптимізації програми можна розглядати такі
	методи оптимізації:
	- машинно-залежні;
	- машинно-незалежні

	На відміну від машинно-незалежних
	методів машинно-залежні методи оптимізації враховують архітектурні особливості
	ЕОМ, наприклад, наявність апаратного стека, наявність вільних регістрів, тощо.
5. _Генерація об'єктного коду._

	**Вхід:** семантичний терм програми.

	**Вихід:** результуючий (об'єктний) код програми.

## Контрольні запитання

1. Які три аспекти як правило виділяють при вивчення мов програмування? 
	<!--прагматичний, синтаксичний, семантичний-->
2. Які два поділи мов програмування в залежності від орієнтації на розв'язання 
	тих чи інших класів задач вам відомі? 
	<!--процедурні/не процедурні і універсальні/спеціалізовані-->
3. Які традиційні функції обробки типу даних "рядок" вам відомі?
	<!--порівняння рядків, виділення підрядка, конкатенація рядків, тощо-->
4. Які два класи задач пов'язаних з синтаксичними структурами програм вам відомі?
	<!--задачі аналізу та задачі синтезу-->
5. Які два типи мовних процесорів вам відомі?
	<!--транслятори та інтерпретатори-->
6. Опишіть структуру транслятора.
	<!--вхід/лесика/синтаксис/семантика/оптимізація/вихід-->
7. Що таке лексема?
	<!--ланцюжок літер, що має певний зміст-->
8. Які два поділи оптимізації ви знаєте? 
	<!--за пам'яттю/часом і машинно-(не)залежні-->

(_традиційні_ відповіді можна переглянути у коментарях у вихідному коді цієї сторінки)